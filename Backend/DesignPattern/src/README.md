# 디자인패턴
### (스프링 입문 전 공부한 디자인 패턴들)

- [x] 어댑터 패턴(Adapter Pattern)
- [x] 프록시 패턴(Proxy Pattern)
- [x] 데코레이터 패턴(Decorator Pattern)
- [x] 싱글턴 패턴(Singleton Pattern)
- [x] 템플릿 메서드 패턴(Template Method Pattern)
- [x] 팩터리 메서드 패턴(Factory Method Pattern)
- [x] 전략 패턴(Strategy Pattern)
- [x] 템플릿 콜백 패턴(Template Callback Pattern - 견본/회신 패턴)
- [] etc) 프론트 컨트롤러 패턴, MVC패턴


# 개념

## 어댑터 패턴(Adapter Pattern)
### "호출당하는 쪽의 메서드를 호출하는 쪽의 코드에 대응하도록 중간에 변환기를 통해 호출하는 패턴"
어댑터 == 변환기(converter)라고 할 수 있다.<br>
변환기의 역할은 서로 다른 두 인터페이스 사이에 통신이 가능하게 하는 것이다.<br>
예를들어 휴대폰충전기의 경우 휴대폰을 직접 전원콘센트에 연결할 수 없기 때문에 충전기가 핸드폰과 전원콘센트 사이에서<br>
둘을 연결해주는 변환기의 역할을 수행한다<br>
<br>
JDBC또한 마찬가지이다. 공통의 인터페이스로 다양한 데이터베이스 시스템을 조작할 수 있다.<br>
결국 어댑터패턴은 객체지향 설계 5원칙중 하나인 OCP 활용한 설계패턴인 것이다.

## 프록시 패턴(Proxy Pattern)
### 제어 흐름을 조정하기 위한 목적으로 중간에 대리자를 두는 패턴
프록시는 대리자, 대변인 이라는 뜻을 가진 단어이다.<br>
프록시 패턴의 경우 실제 객체가 가진 메서드와 같은 이름의 메서드를 사용하는데, 이를위해 인터페이스를 사용한다<br>
(실제 객체를통해 메서드를 호출하고 반환값을 받는지, 대리자 객체를 통해 메서드를 호출하고 반환값을 받는지 전혀 모르게 처리가능)<br>
OCP 및 DIP가 적용된 설계패턴이다.
- 대리자는 실제 서비스와 같은 이름의 메서드를 구현한다. 이때 인터페이스를 사용한다
- 대리자는 실제 서비스에 대한 참조 변수를 갖는다(합성)
- 대리자는 실제 서비스의 같은이름을 가진 메서드를 호출하고 그 값을 클라이언트에게 돌려준다.
- 대리자는 실제 서비스 메서드 호출 전후에 별도의 로직을 수행할 수 있다.<br>

## 데코레이터 패턴(Decorator Pattern)
### 메서드 호출의 반환값에 변화를 주기위해 중간에 장식자를 두는 패턴
데코레이터는 도장/도매업자를 의미한다. 여기서는 장식자라는 뜻을 가지고 논리룰 풀어보자.<br>
데코레이터 패턴이 원본에 장식을 더하는 패턴이라는 것이 이름에 잘 드러나 있다. <b>데코레이터 패턴은 프록시 패턴과 구현방법이 같다<br></b>
다만 프록시 패턴은 클라이언트가 최종적으로 돌려받는 반환값을 조작하지 않고 그대로 전달하는 반면 데코레이터 패턴은 클라이언트가 받는 반환값에 장식을 덧입힌다.
- 장식자는 실제 서비스와 같은 이름의 메서드를 구현한다. 이때 인터페이스를 사용한다.
- 장식자는 실제 서비스에 대한 참조 변수를 갖는다(합성)
- 장식자는 실제 서비스의 같은이름을 가진 메서드를 호출하고 그 <b>반환값에 장식을 더해</b> 클라이언트에게 돌려준다.
- 장식자는 실제 서비스 메서드 호출 전후에 별도의 로직을 수행할 수 있다.<br>

## 싱글턴 패턴(Singleton Pattern)
### 클래스의 인스턴스, 즉 객체를 하나만 만들어 사용하는 패턴
싱글턴 패턴이란 인스턴스를 하나만 만들어 사용하기 위한 패턴이다. 커넥션 풀, 스레드 풀,디바이스 설정 객체 등과 같은경우 인스턴스를 여러 개
만들게 되면 불필요한 자원을 사용하게 되고, 또 프로그램이 예상치 못한 결과를 낳을 수 있다.<br>
싱글턴 패턴은 오직 인스턴스를 하나만 만들고 그것을 계속해서 재사용한다.<br>
<br>
싱글턴 패턴을 적용할 경우 의미상 두 개의 객체가 존재할 수 없다. 이를 구현하려면 객체 생성을 위한 new에 제약을 걸어야 하고,<br>
만들어진 단일 객체를 반환할 수 있는 메서드가 필요하다. 따라서 필요한 요소를 생각해보면 다음 세 가지가 반드시 필요하다.
- new를 실행할 수 없도록 생성자에 private 접근 제어자를 지정한다.
- 유일한 단일 객체를 반환할 수 있는 정적 메서드가 필요하다.
- 유일한 단일 객체를 참조할 정적 참조 변수가 필요하다.<br>

단일 객체인 경우 결국 공유 객체로 사용되기 때문에 속성을 갖지 않게 하는 것이 정석이다.<br>
단일 객체가 속성을 가지면 하나의 참주변수가 변경한 단일 객체의 속성이 다른 참조변수에 영향을 미치기 때문이다.<br>
이는 전역/공유 변수를 가능한 한 사용하지 말라는 지침과 일맥상통한다.(읽기전용 속성으로 하는건 문제 x)<br>
## 템플릿 메서드 패턴(Template Method Pattern)
### 상위 클래스의 견본 메서드에서 하위클래스가 오버라이딩한 메서드를 호출하는 패턴
여러 객체들 사이에서 공통된 동작이 있을 때, 이들을 추상 클래스나 인터페이스로 정의하고, 구체적인 동작은 서브 클래스에서 구현하도록 하는 것이 특징이다.<br>
템플릿 메서드 패턴은 다음과 같은 구조를 가진다.
- 추상 클래스(Abstract Class) 또는 인터페이스(Interface): 공통된 동작을 정의하는 추상 클래스나 인터페이스가 있습니다. 이 추상 클래스나 인터페이스는 템플릿 메서드를 포함하고 있습니다. 템플릿 메서드는 알고리즘의 구조를 정의하고, 구체적인 동작을 호출하는 역할을 합니다.
- 구체 클래스(Concrete Class): 추상 클래스나 인터페이스를 상속하거나 구현하여 템플릿 메서드를 구현합니다. 이 클래스는 추상 클래스나 인터페이스에서 정의한 템플릿 메서드의 구체적인 동작을 제공합니다.

## 팩토리 메서드 패턴(Factory Method Pattern)
### 오버라이드된 메서드가 객체를 반환하는 패턴
객체를 생성하는 인터페이스를 제공하고, 실제로 생성되는 객체의 클래스를 서브 클래스에서 결정하는 패턴. 이를 통해 객체 생성의 책임을 서브 클래스로 분리하여, 객체 생성의 유연성을 높이고, 객체 생성 로직을 캡슐화할 수 있다.<br>
팩토리 메서드 패턴은 다음과 같은 구조를 가집니다:

- Creator(생성자) 클래스: 객체를 생성하는 인터페이스를 제공합니다. 이 클래스는 팩토리 메서드를 포함하고 있습니다. 팩토리 메서드는 객체를 생성하는 추상 메서드로, 실제로 객체를 생성하는 로직이 구현되어 있습니다.

- Concrete Creator(구체 생성자) 클래스: Creator 클래스를 상속받아 팩토리 메서드를 구현합니다. 이 클래스는 실제로 객체를 생성하는 구체적인 로직을 제공합니다. 객체를 생성하여 반환하는 역할을 합니다.

- Product(제품) 클래스: 생성되는 객체의 공통 인터페이스를 정의합니다. Concrete Creator 클래스에서 생성되는 객체들은 이 인터페이스를 구현합니다.

## 전략 패턴(Strategy Pattern)
### 클라이언트가 전략을 생성해 전략을 실행할 컨텍스트에 주입하는 패턴
전략 패턴을 구성하는 세 요소는 꼭 기억해 둬야 한다.
- 전략 메서드를 가진 전략 객체
- 전략 객체를 사용하는 컨텍스트(전략 객체의 사용자/소비자)
- 전략 객체를 생성해 컨텍스트에 주입하는 클라이언트(제3자, 전략 객체의 공급자)<br>

클라이언트는 다양한 전략 중 하나를 선택해 생성한 후 컨택스트에 주입한다.<br>
군인이 있다고 상상해보자. 그리고 그 군인이 사용할 무기가 있다고 하자. 보급 장교가 무기를 군인에게 지급해주면
군인은 주어진 무기에 따라 전투를 수행하게 된다. 이 이야기를 전략패턴에 따라 구분해 보면 무기는 전략이 되고
군인은 컨텍스트, 보급장교는 제3자, 즉 클라이언트가 된다.

## 템플릿 콜백 패턴(Template Callback Pattern - 견본/회신 패턴)
### 전략을 익명 내부 클래스로 구현한 전략 패턴
템플릿 콜백 패턴은 전략 패턴의 변형으로, 스프링의 3대 프로그래밍 모델중 하나인 DI(의존성 주입)에서 사용하는 특별한 형태의 전략 패턴이다.<br>
템플릿 콜백 패턴은 전략 패턴과 모든 것이 동일한데 전략을 익명 내부 클래스로 정의해서 사용한다는 특징이있다.
